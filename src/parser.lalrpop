use ast;
use std::collections::HashMap;

grammar;

pub Root: ast::Root = {
    <a: SystemsDecl> <b: TyDecl*> <c: MessageDecl*> <d: Graph> => {
        ast::Root {
            systems: a,
            types: b,
            messages: c,
            graph: d
        }
    },
};

pub SystemsDecl: ast::SystemsDecl = {
    "systems" <a: Ident> <b: Ident> ";" => ast::SystemsDecl(a, b),
};

pub TyDecls: Vec<ast::TyDecl> = {
    TyDecl* => <>,
};

TyDecl: ast::TyDecl = {
    "type" <Ident> "=" <TyBind> ";" =>
        ast::TyDecl::Type(<>),
    "alias" <Ident> "=" <TyExpr> ";" =>
        ast::TyDecl::Alias(<>)
};

TyBind: ast::Sum = {
    <a: BindTerm> <b: ("|" <BindTerm>)*> => {
        let mut b = b;
        b.insert(0, a);
        ast::Sum(b)
    }
};

BindTerm: ast::SumBind = {
    <Ident> <("of" <TyExpr>)?> =>
        ast::SumBind(<>),
};

TyExpr: ast::Ty = {
    <a: ExprTerm> <b: ("*" <ExprTerm>)*> => {
        let mut b = b;
        b.insert(0, a);
        ast::Ty::Product(b)
    },
};

ExprTerm: ast::Ty = {
    <Ident> <TyOne*> => ast::Ty::TyApply(<>),
    "(" <TyExpr> ")" => <>,
};

TyOne: ast::Ty = {
    Ident => ast::Ty::TyApply(<>, vec![]),
    "(" <TyExpr> ")" => <>,
    IntLiteral => <>,
};

IntLiteral: ast::Ty = {
    r"[0-9]+" => ast::Ty::IntLiteral(<>.to_string()),
};

MessageDecl: ast::MessageDecl = {
    "msg" <sender: Ident> <name: Ident> <t: Ident> ";" => {
        ast::MessageDecl {
            sender: sender,
            name: name,
            t: t,
        }
    },
};

pub Graph: ast::Graph = {
    GraphLine+ => {
        let mut g = ast::Graph::new();
        let mut added = HashMap::new();
        for graphline in <> {
            let mut indices = vec![];
            for ident in graphline {
                if let Some(&i) = added.get(&ident) {
                    indices.push(i);
                } else {
                    let i = g.add_node(ident.clone());
                    indices.push(i);
                    added.insert(ident, i);
                }
            }
            let mut prev = indices[0];
            for cur in indices.into_iter().skip(1) {
                g.add_edge(prev, cur, ());
                prev = cur;
            }
        }
        g
    },
};

pub GraphLine: Vec<ast::GraphIdent> = {
    <a: GraphIdent> <b: ("=>" GraphIdent)+> ";"=> {
        let mut c: Vec<_> = b.into_iter().map(|(_, ident)| ident).collect();
        c.insert(0, a);
        c
    },
};

GraphIdent: ast::GraphIdent = {
    "connect" => ast::GraphIdent::Connect,
    "disconnect" => ast::GraphIdent::Disconnect,
    Ident => ast::GraphIdent::Identifier(<>),
};

Ident: String = {
    // note: this shouldn't match keywords, do something about it.
    r"[a-zA-Z](_?[a-zA-Z0-9])*" => <>.to_string(),
};
